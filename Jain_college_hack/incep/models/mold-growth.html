<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mold Growth Algorithm - Bio-Inspired Blockchain Fraud Detection</title>
    <link rel="stylesheet" href="../styles/main.css">
    <link rel="stylesheet" href="../styles/model-detail.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar">
        <div class="container">
            <div class="logo">
                <h1>BioChainGuard</h1>
            </div>
            <ul class="nav-links">
                <li><a href="../index.html#overview">Overview</a></li>
                <li><a href="../index.html#problem">Problem</a></li>
                <li><a href="../index.html#models">Models</a></li>
                <li><a href="../index.html#visualizer">Visualizer</a></li>
                <li><a href="../index.html#tech">Tech Stack</a></li>
            </ul>
        </div>
    </nav>

    <!-- Hero Section -->
    <section class="model-hero mold-hero">
        <div class="container">
            <div class="model-hero-content">
                <div class="model-icon">
                    <i class="fas fa-seedling"></i>
                </div>
                <h1>Mold Growth Algorithm</h1>
                <p>Bio-Inspired Fraud Path Discovery for Blockchain Networks</p>
                <a href="infection-simulation.html" class="model-button">SIMULATION</a>
            </div>
        </div>
    </section>

    <!-- Model Overview Section -->
    <section class="model-overview">
        <div class="container">
            <div class="section-header">
                <h2>Model Overview</h2>
            </div>
            <div class="model-overview-content">
                <p>The Mold Growth Algorithm is inspired by the foraging behavior of slime molds, which can find optimal paths between food sources despite having no central intelligence. This model uses virtual "mold agents" that propagate from trusted accounts, identifying the safest transaction corridors and revealing potential fraud zones.</p>
                <p>Unlike traditional path-finding algorithms, the Mold Growth Algorithm adapts continuously to changing conditions in the blockchain network, creating a dynamic map of transaction safety that evolves as new transactions occur and fraud patterns emerge.</p>
            </div>
        </div>
    </section>

    <!-- How It Works Section -->
    <section class="how-it-works">
        <div class="container">
            <div class="section-header">
                <h2>How It Works</h2>
            </div>
            <div class="how-it-works-content">
                <div class="step">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <h3>Trusted Seed Accounts</h3>
                        <p>The algorithm begins with a set of trusted seed accounts that serve as the starting points for mold growth:</p>
                        <ul>
                            <li>Verified institutional accounts</li>
                            <li>Long-established accounts with clean transaction histories</li>
                            <li>Accounts that have passed enhanced verification</li>
                            <li>Accounts designated as trusted by system administrators</li>
                        </ul>
                    </div>
                </div>
                <div class="step">
                    <div class="step-number">2</div>
                    <div class="step-content">
                        <h3>Mold Agent Propagation</h3>
                        <p>Virtual mold agents propagate outward from trusted accounts through transaction pathways:</p>
                        <ul>
                            <li>Agents follow transaction edges in the blockchain graph</li>
                            <li>Each agent deposits a "trail" on the paths it traverses</li>
                            <li>Trails strengthen when multiple agents follow the same path</li>
                            <li>Trails gradually evaporate over time if not reinforced</li>
                        </ul>
                    </div>
                </div>
                <div class="step">
                    <div class="step-number">3</div>
                    <div class="step-content">
                        <h3>Environmental Response</h3>
                        <p>Mold agents respond to environmental factors in the blockchain:</p>
                        <ul>
                            <li><strong>Attractants:</strong> Healthy transaction patterns and verified accounts</li>
                            <li><strong>Repellents:</strong> Suspicious activity, anomalous transactions, and known fraud</li>
                            <li><strong>Nutrients:</strong> Transaction volume and frequency (determines growth rate)</li>
                            <li><strong>Obstacles:</strong> High-risk accounts and transaction patterns</li>
                        </ul>
                    </div>
                </div>
                <div class="step">
                    <div class="step-number">4</div>
                    <div class="step-content">
                        <h3>Path Analysis</h3>
                        <p>The resulting mold growth pattern reveals important insights:</p>
                        <ul>
                            <li><strong>Strong Trails:</strong> Safe, frequently used transaction corridors</li>
                            <li><strong>Dead Zones:</strong> Areas avoided by mold agents, indicating potential fraud</li>
                            <li><strong>Growth Boundaries:</strong> Transition zones between safe and risky areas</li>
                            <li><strong>Isolated Islands:</strong> Account clusters disconnected from trusted networks</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Key Features Section -->
    <section class="key-features">
        <div class="container">
            <div class="section-header">
                <h2>Key Features</h2>
            </div>
            <div class="key-features-content">
                <div class="feature-card">
                    <div class="feature-icon">
                        <i class="fas fa-route"></i>
                    </div>
                    <h3>Optimal Path Finding</h3>
                    <p>Identifies the safest transaction corridors between accounts, enabling risk-aware routing of high-value transactions.</p>
                </div>
                <div class="feature-card">
                    <div class="feature-icon">
                        <i class="fas fa-map-marked-alt"></i>
                    </div>
                    <h3>Fraud Zone Mapping</h3>
                    <p>Creates a dynamic map of the blockchain network that highlights areas with high fraud risk and safe transaction zones.</p>
                </div>
                <div class="feature-card">
                    <div class="feature-icon">
                        <i class="fas fa-bezier-curve"></i>
                    </div>
                    <h3>Adaptive Navigation</h3>
                    <p>Continuously adapts to changing conditions in the blockchain, rerouting around newly discovered fraud zones.</p>
                </div>
                <div class="feature-card">
                    <div class="feature-icon">
                        <i class="fas fa-puzzle-piece"></i>
                    </div>
                    <h3>Emergent Intelligence</h3>
                    <p>Demonstrates emergent collective intelligence, where simple agent behaviors create sophisticated fraud detection patterns.</p>
                </div>
            </div>
        </div>
    </section>

    <!-- Visualization Section -->
    <section class="visualization">
        <div class="container">
            <div class="section-header">
                <h2>Visualization</h2>
            </div>
            <div class="visualization-content">
                <div class="visualization-description">
                    <p>The Mold Growth Algorithm outputs are visualized as an interactive network map showing the growth patterns of virtual mold agents across the blockchain transaction graph.</p>
                    <p>The visualization uses color intensity to represent trail strength, with animated growth patterns showing how the mold explores and adapts to the transaction environment in real-time.</p>
                </div>
                <div class="visualization-image">
                    <img src="../images/mold-growth-map.jpg" alt="Mold Growth Algorithm Visualization">
                </div>
                <div class="visualization-details">
                    <h3>Interpreting the Visualization</h3>
                    <ul>
                        <li><strong>Bright Green Trails:</strong> Strong, frequently used safe paths</li>
                        <li><strong>Faint Green Trails:</strong> Emerging or less frequently used safe paths</li>
                        <li><strong>Red Areas:</strong> Dead zones avoided by mold agents (potential fraud)</li>
                        <li><strong>Yellow Boundaries:</strong> Transition zones between safe and risky areas</li>
                        <li><strong>Blue Nodes:</strong> Trusted seed accounts where mold growth begins</li>
                        <li><strong>Gray Areas:</strong> Unexplored regions of the transaction graph</li>
                    </ul>
                </div>
            </div>
        </div>
    </section>

    <!-- Technical Implementation Section -->
    <section class="technical-implementation">
        <div class="container">
            <div class="section-header">
                <h2>Technical Implementation</h2>
            </div>
            <div class="technical-content">
                <div class="code-block">
                    <pre><code>
# Simplified Python implementation of Mold Growth Algorithm
import networkx as nx
import numpy as np
from collections import defaultdict

class MoldGrowthAlgorithm:
    def __init__(self, evaporation_rate=0.05, deposit_amount=1.0, 
                 exploration_rate=0.2, trusted_seeds=None):
        # Initialize parameters
        self.evaporation_rate = evaporation_rate  # Rate at which trails evaporate
        self.deposit_amount = deposit_amount      # Amount of trail deposited by agents
        self.exploration_rate = exploration_rate  # Probability of random exploration
        
        # Initialize transaction graph
        self.graph = nx.DiGraph()
        
        # Initialize trail map (edge weights)
        self.trail_map = defaultdict(float)
        
        # Initialize trusted seed accounts
        self.trusted_seeds = trusted_seeds or []
        
        # Initialize mold agents
        self.agents = []
        self._initialize_agents()
        
        # Risk scores for accounts
        self.account_risk_scores = {}
    
    def add_trusted_seed(self, account_id):
        """Add a trusted seed account for mold growth"""
        if account_id not in self.trusted_seeds:
            self.trusted_seeds.append(account_id)
            
            # Create new agents at this seed
            self._create_agents_at_seed(account_id)
    
    def _initialize_agents(self):
        """Initialize mold agents at trusted seed accounts"""
        for seed in self.trusted_seeds:
            self._create_agents_at_seed(seed)
    
    def _create_agents_at_seed(self, seed, num_agents=10):
        """Create new mold agents at a seed account"""
        if seed not in self.graph:
            self.graph.add_node(seed)
            
        for _ in range(num_agents):
            self.agents.append({
                'position': seed,
                'previous_position': None,
                'age': 0,
                'energy': 100
            })
    
    def process_transaction(self, transaction):
        """Process a new blockchain transaction"""
        sender = transaction['sender']
        recipient = transaction['recipient']
        amount = transaction['amount']
        timestamp = transaction['timestamp']
        
        # Add accounts if they don't exist
        for account in [sender, recipient]:
            if account not in self.graph:
                self.graph.add_node(account)
                
                # Initialize risk score if not exists
                if account not in self.account_risk_scores:
                    self.account_risk_scores[account] = 0.5  # Default neutral risk
        
        # Update or add edge
        if self.graph.has_edge(sender, recipient):
            # Update existing edge
            self.graph[sender][recipient]['weight'] += amount
            self.graph[sender][recipient]['transactions'] += 1
            self.graph[sender][recipient]['last_timestamp'] = timestamp
        else:
            # Add new edge
            self.graph.add_edge(sender, recipient, weight=amount, 
                               transactions=1, last_timestamp=timestamp)
        
        # Update mold growth simulation
        self._simulate_mold_growth()
        
        # Calculate path safety scores
        path_safety = self._calculate_path_safety(sender, recipient)
        
        return {
            'path_safety': path_safety,
            'sender_risk': self.account_risk_scores[sender],
            'recipient_risk': self.account_risk_scores[recipient]
        }
    
    def _simulate_mold_growth(self, steps=10):
        """Simulate mold growth for a number of steps"""
        for _ in range(steps):
            # Evaporate trails
            for edge, trail in self.trail_map.items():
                self.trail_map[edge] = max(0, trail * (1 - self.evaporation_rate))
            
            # Move agents
            self._move_agents()
            
            # Create new agents at seeds (with low probability)
            if np.random.random() < 0.1:
                for seed in self.trusted_seeds:
                    if np.random.random() < 0.3:
                        self._create_agents_at_seed(seed, num_agents=3)
    
    def _move_agents(self):
        """Move all mold agents one step"""
        new_agents = []
        
        for agent in self.agents:
            # Increase age
            agent['age'] += 1
            
            # Decrease energy
            agent['energy'] -= 1
            
            # Remove agent if out of energy
            if agent['energy'] <= 0:
                continue
            
            current_position = agent['position']
            
            # Get possible next positions (outgoing edges)
            neighbors = list(self.graph.successors(current_position))
            
            if not neighbors:
                # No outgoing edges, agent dies
                continue
            
            # Choose next position based on trail strength and exploration
            if np.random.random() < self.exploration_rate:
                # Random exploration
                next_position = np.random.choice(neighbors)
            else:
                # Follow strongest trail, weighted by trail strength and inverse risk
                weights = []
                for neighbor in neighbors:
                    edge = (current_position, neighbor)
                    trail_strength = self.trail_map.get(edge, 0)
                    risk_factor = 1 - self.account_risk_scores.get(neighbor, 0.5)
                    weight = (trail_strength + 0.1) * risk_factor
                    weights.append(weight)
                
                # Normalize weights
                total_weight = sum(weights) or 1
                weights = [w / total_weight for w in weights]
                
                next_position = np.random.choice(neighbors, p=weights)
            
            # Deposit trail on the chosen edge
            edge = (current_position, next_position)
            self.trail_map[edge] = self.trail_map.get(edge, 0) + self.deposit_amount
            
            # Update agent position
            agent['previous_position'] = current_position
            agent['position'] = next_position
            
            # Agent reproduction (with low probability)
            if np.random.random() < 0.05 and agent['energy'] > 50:
                # Create a new agent at the same position
                new_agent = {
                    'position': agent['position'],
                    'previous_position': agent['previous_position'],
                    'age': 0,
                    'energy': agent['energy'] // 2
                }
                agent['energy'] = agent['energy'] // 2
                new_agents.append(new_agent)
            
            # Keep agent
            new_agents.append(agent)
        
        # Update agents list
        self.agents = new_agents
    
    def _calculate_path_safety(self, source, target):
        """Calculate safety score for a path between source and target"""
        # Try to find a path
        try:
            path = nx.shortest_path(self.graph, source=source, target=target)
        except (nx.NetworkXNoPath, nx.NodeNotFound):
            return 0.0  # No path exists
        
        # Calculate average trail strength along the path
        total_strength = 0
        for i in range(len(path) - 1):
            edge = (path[i], path[i+1])
            total_strength += self.trail_map.get(edge, 0)
        
        avg_strength = total_strength / (len(path) - 1) if len(path) > 1 else 0
        
        # Normalize to 0-1 range
        safety_score = min(1.0, avg_strength / 10)
        
        return safety_score
    
    def update_account_risk_scores(self):
        """Update risk scores for all accounts based on mold growth patterns"""
        # Calculate total trail strength for each node
        node_trail_strengths = defaultdict(float)
        
        for edge, strength in self.trail_map.items():
            source, target = edge
            node_trail_strengths[source] += strength
            node_trail_strengths[target] += strength
        
        # Update risk scores (inverse relationship to trail strength)
        for account in self.graph.nodes():
            trail_strength = node_trail_strengths.get(account, 0)
            
            # Normalize trail strength (0-1 range)
            normalized_strength = min(1.0, trail_strength / 20)
            
            # Trusted seeds always have low risk
            if account in self.trusted_seeds:
                self.account_risk_scores[account] = 0.1
            else:
                # Higher trail strength = lower risk
                self.account_risk_scores[account] = max(0.1, 1.0 - normalized_strength)
        
        return self.account_risk_scores
    
    def get_fraud_zones(self):
        """Identify potential fraud zones (areas avoided by mold)"""
        fraud_zones = []
        
        # Find connected components in the graph
        components = list(nx.weakly_connected_components(self.graph))
        
        for component in components:
            # Skip small components
            if len(component) < 5:
                continue
                
            # Calculate average trail strength in this component
            component_edges = []
            for node in component:
                for neighbor in self.graph.successors(node):
                    if neighbor in component:
                        component_edges.append((node, neighbor))
            
            if not component_edges:
                continue
                
            avg_trail = sum(self.trail_map.get(edge, 0) for edge in component_edges) / len(component_edges)
            
            # If average trail is very low, this might be a fraud zone
            if avg_trail < 0.5:
                fraud_zones.append({
                    'nodes': list(component),
                    'avg_trail': avg_trail,
                    'size': len(component)
                })
        
        return fraud_zones
                    </code></pre>
                </div>
            </div>
        </div>
    </section>

    <!-- Use Cases Section -->
    <section class="use-cases">
        <div class="container">
            <div class="section-header">
                <h2>Use Cases</h2>
            </div>
            <div class="use-cases-content">
                <div class="use-case">
                    <h3>Safe Transaction Routing</h3>
                    <p>The Mold Growth Algorithm can identify the safest paths for routing high-value transactions through the blockchain network, minimizing exposure to potentially fraudulent accounts.</p>
                </div>
                <div class="use-case">
                    <h3>Fraud Cluster Identification</h3>
                    <p>By identifying "dead zones" where mold agents avoid growth, the algorithm can reveal clusters of potentially fraudulent accounts that operate in isolation from legitimate transaction networks.</p>
                </div>
                <div class="use-case">
                    <h3>Trust Network Expansion</h3>
                    <p>The algorithm can guide the strategic expansion of trusted account networks by identifying promising new connections that maintain high safety levels while increasing network reach.</p>
                </div>
                <div class="use-case">
                    <h3>Anomalous Subgraph Detection</h3>
                    <p>The model can identify subgraphs with unusual mold growth patterns, revealing transaction structures that don't conform to normal patterns but may not be detected by traditional anomaly detection methods.</p>
                </div>
            </div>
        </div>
    </section>

    <!-- Back to Main Button -->
    <div class="back-to-main">
        <div class="container">
            <a href="../index.html" class="btn-primary">
                <i class="fas fa-arrow-left"></i> Back to Main Page
            </a>
        </div>
    </div>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-logo">
                    <h2>BioChainGuard</h2>
                    <p>Bio-Inspired Blockchain Fraud Detection Suite</p>
                </div>
                <div class="footer-links">
                    <h3>Quick Links</h3>
                    <ul>
                        <li><a href="../index.html#overview">Overview</a></li>
                        <li><a href="../index.html#problem">Problem</a></li>
                        <li><a href="../index.html#models">Models</a></li>
                        <li><a href="../index.html#visualizer">Visualizer</a></li>
                        <li><a href="../index.html#tech">Tech Stack</a></li>
                    </ul>
                </div>
                <div class="footer-contact">
                    <h3>Contact</h3>
                    <p>For more information about this project, please contact us.</p>
                    <a href="mailto:info@biochainfraud.com" class="btn-secondary">Contact Us</a>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Bio-Inspired Blockchain Fraud Detection Suite. All rights reserved.</p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="../js/main.js"></script>
</body>
</html>
